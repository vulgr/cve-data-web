import zlib
from collections import OrderedDict
from datetime import datetime

import requests
import xmltodict

from utils import CPEParser
from utils import CVEWriterQueues
from utils import NeoCSVWriter
from utils import get_logger


class CVEParser:
    def __init__(self, outputdir=None):
        self.writer = NeoCSVWriter(outputdir)
        self.logger = get_logger('CVE')
        self.cpeparser = CPEParser()
        self.queues = CVEWriterQueues()

    def retrieve_feed(self, url):
        """
        Returns dictionary of contents from downloaded gzip NVD CVE feed.
        :param url: GZipped file location
        :return: boolean
        """
        self.logger.info('Downloading {}. . .'.format(url))
        resp = requests.get(url, stream=True)
        if not resp.ok:
            raise requests.RequestException('Error retrieving {}.'.format(url))
        self.logger.info('Download complete. Parsing. . .')
        # Streaming HTTP response to zlib to xmltodict to add_cve_entry.
        xmltodict.parse(zlib.decompress(resp.content, 16 + zlib.MAX_WBITS),
                        item_depth=2,
                        item_callback=self.add_cve_entry)
        self.logger.info('XML parsing complete.')
        cveq = self.queues.cvewriterqueue.qsize()
        prodq = self.queues.productwriterqueue.qsize()
        refq = self.queues.referencewriterqueue.qsize()
        self.logger.info('CVE writer queue size: {}'.format(cveq))
        self.logger.info('Product writer queue size: {}'.format(prodq))
        self.logger.info('References writer queue size: {}'.format(refq))

    def add_batch_to_csv(self, filename, rows):
        """
        Add a list of rows to filename.
        :param filename: filename to write to.
        :param rows: list of lists to append to filename.
        """
        self.writer.csv_append_multiple_rows(filename, rows)

    def build_product_lists(self, cpelist):
        """
        Given a list of CPE strings, pull out the product info and return
         as list of lists.
        :param cpelist: List of standard CPE URIs as strings
        :return: list of lists with CPE data
        """
        prodlist = list()
        # Put single entries into a list.
        if isinstance(cpelist, unicode):
            cpelist = [cpelist]
        for item in cpelist:
            data = self.cpeparser.convert_cpe_uri_to_list(item)
            prodlist.append(data)
        cpelist[:] = []
        return prodlist

    def add_cve_entry(self, path, entry):
        """
        Parse CVE entry from xmltodict's stream.
        :param path: path in XML file, ignored.
        :param entry: CVE entry in XML file.
        :return: True
        """
        cveid = entry.get('vuln:cve-id')
        summary = entry.get('vuln:summary')
        summary = ''.join(summary).encode('utf-8').strip()
        q = self.queues.cvewriterqueue
        addrow = self.writer.csv_append_row
        q.put([addrow, self.writer.CVEFILE, cveid, summary, 'CVE'])
        for key, value in entry.iteritems():
            if key == 'vuln:vulnerable-software-list':
                self.parse_products(cveid, value.get('vuln:product'))
            if key == 'vuln:references':
                self.parse_references(cveid, value)
            if key == 'vuln:cwe':
                self.parse_cwes(cveid, value)
        return True

    def parse_products(self, cveid, products):
        """
        Parse product data and write node/relationship data to CSVs.
        :param cveid: CVE ID as string
        :param products: products as list
        """
        data = self.build_product_lists(products)
        productrows = list()
        affectsrows = list()
        vendorrows = list()
        ownsrows = list()
        partrows = list()
        for product in data:
            # See CPEParser docstrings for index refs here.
            productrows.append([product[0], product[3], str(product[5]),
                                str(product[4]),
                                'Product'])
            affectsrows.append([cveid, product[0], 'Affects'])
            vendorrows.append([product[2], 'Vendor'])
            ownsrows.append([product[2], product[0], 'Owns'])
            partrows.append([product[0], product[1], 'IsPart'])
        q = self.queues.productwriterqueue
        batchadd = self.add_batch_to_csv
        q.put([batchadd, self.writer.PRODUCTFILE, productrows])
        q.put([batchadd, self.writer.AFFECTSFILE, affectsrows])
        q.put([batchadd, self.writer.VENDORFILE, vendorrows])
        q.put([batchadd, self.writer.OWNSFILE, ownsrows])
        q.put([batchadd, self.writer.ISPARTFILE, partrows])

    def parse_references(self, cveid, references):
        """
        Parse reference data and write node/relationship data to CSVs.
        :param cveid: CVE ID as string
        :param references: references as list
        """
        # Put single reference entries into a list.
        if isinstance(references, OrderedDict):
            references = [references]
        reflist = list()
        reftypelist = list()
        refsourcelist = list()
        isreftypelist = list()
        hasreflist = list()
        fromrefsourcelist = list()
        for ref in references:
            href = ref.get('vuln:reference').get('@href')
            reftype = ref.get('@reference_type')
            refsource = ref.get('vuln:source')
            reflist.append([href, 'Reference'])
            reftypelist.append([reftype, 'ReferenceType'])
            refsourcelist.append([refsource, 'ReferenceSource'])
            isreftypelist.append([href, reftype, 'IsRefType'])
            hasreflist.append([cveid, href, 'HasReference'])
            fromrefsourcelist.append([href, refsource, 'FromRefSource'])
        q = self.queues.referencewriterqueue
        batchadd = self.add_batch_to_csv
        q.put([batchadd, self.writer.REFERENCEFILE, reflist])
        q.put([batchadd, self.writer.REFTYPEFILE, reftypelist])
        q.put([batchadd, self.writer.REFSOURCEFILE, refsourcelist])
        q.put([batchadd, self.writer.ISREFTYPEFILE, isreftypelist])
        q.put([batchadd, self.writer.HASREFERENCEFILE, hasreflist])
        q.put([batchadd, self.writer.FROMREFSROUCEFILE, fromrefsourcelist])

    def parse_cwes(self, cveid, cwes):
        """
        Parse CWE data and write node/relationship data to CSVs.
        :param cveid: CVE ID as string.
        :param cwes: CWEs as list.
        """
        cwelist = list()
        cwlist = list()
        # Put single CWE entries into a list.
        if isinstance(cwes, dict):
            cwes = [cwes]
        for cwe in cwes:
            cweid = cwe.get('@id')
            cwelist.append([cweid, 'CWE'])
            cwlist.append([cveid, cweid, 'CommonWeakness'])
        q = self.queues.cvewriterqueue
        batchadd = self.add_batch_to_csv
        q.put([batchadd, self.writer.CWEFILE, cwelist])
        q.put([batchadd, self.writer.COMMONWEAKNESSFILE, cwlist])

    def main(self):
        self.writer.setup_files()
        current = datetime.utcnow().year
        for year in range(2002, current + 1):
            url = 'https://nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-{}.xml.gz'
            self.retrieve_feed(url.format(year))
        self.logger.info('Downloads consumed. Waiting for threads. . .')
        for q in self.queues.queues:
            q.join()
        self.logger.info('Writer threads complete.')
        for result in self.writer.OUTPUTS:
            self.writer.remove_duplicates(result)
        self.logger.info('All done, bye bye.')


if __name__ == '__main__':
    CVEParser('output').main()
